{"version":3,"sources":["webpack:///./node_modules/@writewithocto/ink/dist/es/r-785e7577.js"],"names":["wordObj","words","res","i","length","curPunc","commonAtoms","commonBuiltins","commonKeywords","commonBlockKeywords","atoms","builtins","keywords","blockkeywords","opChars","tokenBase","stream","state","ch","next","skipToEnd","eat","eatWhile","match","test","tokenize","tokenString","word","current","propertyIsEnumerable","skipTo","ctx","argList","quote","backUp","ALIGN_YES","ALIGN_NO","BRACELESS","push","type","indent","flags","column","prev","setFlag","flag","pop","r","startState","indentUnit","afterIdent","token","sol","indentation","eatSpace","style","textAfter","cx","firstChar","charAt","closing","unit","languageData","wordChars","commentTokens","line","autocomplete","concat"],"mappings":"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","file":"js/chunk-2d210ba0.7d03fcc9.js","sourcesContent":["function wordObj(words) {\n  var res = {};\n  for (var i = 0; i < words.length; ++i) res[words[i]] = true;\n  return res;\n}\nvar commonAtoms = [\"NULL\", \"NA\", \"Inf\", \"NaN\", \"NA_integer_\", \"NA_real_\", \"NA_complex_\", \"NA_character_\", \"TRUE\", \"FALSE\"];\nvar commonBuiltins = [\"list\", \"quote\", \"bquote\", \"eval\", \"return\", \"call\", \"parse\", \"deparse\"];\nvar commonKeywords = [\"if\", \"else\", \"repeat\", \"while\", \"function\", \"for\", \"in\", \"next\", \"break\"];\nvar commonBlockKeywords = [\"if\", \"else\", \"repeat\", \"while\", \"function\", \"for\"];\n\nvar atoms = wordObj(commonAtoms);\nvar builtins = wordObj(commonBuiltins);\nvar keywords = wordObj(commonKeywords);\nvar blockkeywords = wordObj(commonBlockKeywords);\nvar opChars = /[+\\-*\\/^<>=!&|~$:]/;\nvar curPunc;\n\nfunction tokenBase(stream, state) {\n  curPunc = null;\n  var ch = stream.next();\n  if (ch == \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  } else if (ch == \"0\" && stream.eat(\"x\")) {\n    stream.eatWhile(/[\\da-f]/i);\n    return \"number\";\n  } else if (ch == \".\" && stream.eat(/\\d/)) {\n    stream.match(/\\d*(?:e[+\\-]?\\d+)?/);\n    return \"number\";\n  } else if (/\\d/.test(ch)) {\n    stream.match(/\\d*(?:\\.\\d+)?(?:e[+\\-]\\d+)?L?/);\n    return \"number\";\n  } else if (ch == \"'\" || ch == '\"') {\n    state.tokenize = tokenString(ch);\n    return \"string\";\n  } else if (ch == \"`\") {\n    stream.match(/[^`]+`/);\n    return \"string.special\";\n  } else if (ch == \".\" && stream.match(/.(?:[.]|\\d+)/)) {\n    return \"keyword\";\n  } else if (/[a-zA-Z\\.]/.test(ch)) {\n    stream.eatWhile(/[\\w\\.]/);\n    var word = stream.current();\n    if (atoms.propertyIsEnumerable(word)) return \"atom\";\n    if (keywords.propertyIsEnumerable(word)) {\n      // Block keywords start new blocks, except 'else if', which only starts\n      // one new block for the 'if', no block for the 'else'.\n      if (blockkeywords.propertyIsEnumerable(word) &&\n          !stream.match(/\\s*if(\\s+|$)/, false))\n        curPunc = \"block\";\n      return \"keyword\";\n    }\n    if (builtins.propertyIsEnumerable(word)) return \"builtin\";\n    return \"variable\";\n  } else if (ch == \"%\") {\n    if (stream.skipTo(\"%\")) stream.next();\n    return \"variableName.special\";\n  } else if (\n    (ch == \"<\" && stream.eat(\"-\")) ||\n      (ch == \"<\" && stream.match(\"<-\")) ||\n      (ch == \"-\" && stream.match(/>>?/))\n  ) {\n    return \"operator\";\n  } else if (ch == \"=\" && state.ctx.argList) {\n    return \"operator\";\n  } else if (opChars.test(ch)) {\n    if (ch == \"$\") return \"operator\";\n    stream.eatWhile(opChars);\n    return \"operator\";\n  } else if (/[\\(\\){}\\[\\];]/.test(ch)) {\n    curPunc = ch;\n    if (ch == \";\") return \"punctuation\";\n    return null;\n  } else {\n    return null;\n  }\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    if (stream.eat(\"\\\\\")) {\n      var ch = stream.next();\n      if (ch == \"x\") stream.match(/^[a-f0-9]{2}/i);\n      else if ((ch == \"u\" || ch == \"U\") && stream.eat(\"{\") && stream.skipTo(\"}\")) stream.next();\n      else if (ch == \"u\") stream.match(/^[a-f0-9]{4}/i);\n      else if (ch == \"U\") stream.match(/^[a-f0-9]{8}/i);\n      else if (/[0-7]/.test(ch)) stream.match(/^[0-7]{1,2}/);\n      return \"string.special\";\n    } else {\n      var next;\n      while ((next = stream.next()) != null) {\n        if (next == quote) { state.tokenize = tokenBase; break; }\n        if (next == \"\\\\\") { stream.backUp(1); break; }\n      }\n      return \"string\";\n    }\n  };\n}\n\nvar ALIGN_YES = 1, ALIGN_NO = 2, BRACELESS = 4;\n\nfunction push(state, type, stream) {\n  state.ctx = {type: type,\n               indent: state.indent,\n               flags: 0,\n               column: stream.column(),\n               prev: state.ctx};\n}\nfunction setFlag(state, flag) {\n  var ctx = state.ctx;\n  state.ctx = {type: ctx.type,\n               indent: ctx.indent,\n               flags: ctx.flags | flag,\n               column: ctx.column,\n               prev: ctx.prev};\n}\nfunction pop(state) {\n  state.indent = state.ctx.indent;\n  state.ctx = state.ctx.prev;\n}\n\nconst r = {\n  startState: function(indentUnit) {\n    return {tokenize: tokenBase,\n            ctx: {type: \"top\",\n                  indent: -indentUnit,\n                  flags: ALIGN_NO},\n            indent: 0,\n            afterIdent: false};\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if ((state.ctx.flags & 3) == 0) state.ctx.flags |= ALIGN_NO;\n      if (state.ctx.flags & BRACELESS) pop(state);\n      state.indent = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (style != \"comment\" && (state.ctx.flags & ALIGN_NO) == 0) setFlag(state, ALIGN_YES);\n\n    if ((curPunc == \";\" || curPunc == \"{\" || curPunc == \"}\") && state.ctx.type == \"block\") pop(state);\n    if (curPunc == \"{\") push(state, \"}\", stream);\n    else if (curPunc == \"(\") {\n      push(state, \")\", stream);\n      if (state.afterIdent) state.ctx.argList = true;\n    }\n    else if (curPunc == \"[\") push(state, \"]\", stream);\n    else if (curPunc == \"block\") push(state, \"block\", stream);\n    else if (curPunc == state.ctx.type) pop(state);\n    else if (state.ctx.type == \"block\" && style != \"comment\") setFlag(state, BRACELESS);\n    state.afterIdent = style == \"variable\" || style == \"keyword\";\n    return style;\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != tokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), ctx = state.ctx,\n        closing = firstChar == ctx.type;\n    if (ctx.flags & BRACELESS) ctx = ctx.prev;\n    if (ctx.type == \"block\") return ctx.indent + (firstChar == \"{\" ? 0 : cx.unit);\n    else if (ctx.flags & ALIGN_YES) return ctx.column + (closing ? 0 : 1);\n    else return ctx.indent + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    wordChars: \".\",\n    commentTokens: {line: \"#\"},\n    autocomplete: commonAtoms.concat(commonBuiltins, commonKeywords)\n  }\n};\n\nexport { r };\n"],"sourceRoot":""}