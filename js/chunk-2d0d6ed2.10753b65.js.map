{"version":3,"sources":["webpack:///./node_modules/@writewithocto/ink/dist/es/index-bcaba2ed.js"],"names":["StartTag","StartCloseTag","mismatchedStartCloseTag","incompleteStartCloseTag","commentContent","piContent","cdataContent","Element$1","OpenTag","nameChar","ch","isSpace","cachedName","cachedInput","cachedPos","tagNameAfter","input","pos","next","get","start","read","toLowerCase","ElementContext","name","parent","this","hash","i","length","charCodeAt","elementContext","ContextTracker","shift","context","term","stack","reduce","reuse","node","type","id","strict","startTag","ExternalTokenizer","token","accept","cx","scanTo","end","endPos","commentContent$1","piContent$1","cdataContent$1","parser","Parser","deserialize","version","states","stateData","goto","nodeNames","maxTerm","nodeProps","NodeProp","closedBy","openedBy","skippedNodes","repeatNodeCount","tokenData","tokenizers","topRules","tokenPrec","tagName","doc","tag","getChild","sliceString","from","to","elementName","tree","firstChild","attrName","attr","getChildren","find","a","findParentElement","cur","findLocation","state","_a","at","syntaxTree","resolve","inTag","lastChild","isError","elt","before","childBefore","Element","spec","attrs","attrValues","children","completion","Object","assign","label","openCompletion","closeCompletion","boost","closeNameCompletion","text","textContent","map","s","Identifier","attrCompletion","valueCompletion","test","completeFromSchema","eltSpecs","attrSpecs","allAttrs","globalAttrs","create","push","global","values","allElements","topElements","byName","attrVals","attributes","concat","top","loc","explicit","parentName","options","span","closing","last","e","openTag","sliceDoc","xmlLanguage","LezerLanguage","define","configure","props","indentNodeProp","add","closed","textAfter","lineIndent","lineAt","unit","column","foldNodeProp","subtree","first","styleTags","AttributeValue","tags","string","Text","content","angleBracket","TagName","invalid","AttributeName","propertyName","UnquotedAttributeValue","Is","definitionOperator","character","Comment","blockComment","ProcessingInst","processingInstruction","DoctypeDecl","documentMeta","Cdata","special","languageData","commentTokens","block","open","close","indentOnInput","xml","conf","LanguageSupport","data","of","autocomplete","elements"],"mappings":"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","file":"js/chunk-2d0d6ed2.10753b65.js","sourcesContent":["import { C as ContextTracker, E as ExternalTokenizer, P as Parser, o as NodeProp, j as LezerLanguage, e as indentNodeProp, h as foldNodeProp, a as styleTags, t as tags, n as LanguageSupport, s as syntaxTree } from './index-8d5ff86c.js';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst StartTag = 1,\n  StartCloseTag = 2,\n  mismatchedStartCloseTag = 3,\n  incompleteStartCloseTag = 4,\n  commentContent = 35,\n  piContent = 36,\n  cdataContent = 37,\n  Element$1 = 9,\n  OpenTag = 11;\n\n/* Hand-written tokenizer for XML tag matching. */\n\nfunction nameChar(ch) {\n  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161\n}\n\nfunction isSpace(ch) {\n  return ch == 9 || ch == 10 || ch == 13 || ch == 32\n}\n\nlet cachedName = null, cachedInput = null, cachedPos = 0;\nfunction tagNameAfter(input, pos) {\n  if (cachedPos == pos && cachedInput == input) return cachedName\n  let next = input.get(pos);\n  while (isSpace(next)) next = input.get(++pos);\n  let start = pos;\n  while (nameChar(next)) next = input.get(++pos);\n  // Undefined to signal there's a <? or <!, null for just missing\n  cachedInput = input; cachedPos = pos;\n  return cachedName = pos > start ? input.read(start, pos).toLowerCase() : null\n}\n\nfunction ElementContext(name, parent) {\n  this.name = name;\n  this.parent = parent;\n  this.hash = parent ? parent.hash : 0;\n  for (let i = 0; i < name.length; i++) this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);\n}\n\nconst elementContext = new ContextTracker({\n  start: null,\n  shift(context, term, input, stack) {\n    return term == StartTag ? new ElementContext(tagNameAfter(input, stack.pos) || \"\", context) : context\n  },\n  reduce(context, term) {\n    return term == Element$1 && context ? context.parent : context\n  },\n  reuse(context, node, input, stack) {\n    let type = node.type.id;\n    return type == StartTag || type == OpenTag\n      ? new ElementContext(tagNameAfter(input, stack.pos - node.length + 1) || \"\", context) : context\n  },\n  hash(context) { return context ? context.hash : 0 },\n  strict: false\n});\n\nconst startTag = new ExternalTokenizer((input, token, stack) => {\n  let pos = token.start;\n  if (input.get(pos++) != 60 /* '<' */) return\n  let next = input.get(pos);\n  if (next == 47 /* '/' */) {\n    pos++;\n    let name = tagNameAfter(input, pos);\n    if (!name) return token.accept(incompleteStartCloseTag, pos)\n    if (stack.context && name == stack.context.name) return token.accept(StartCloseTag, pos)\n    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return\n    token.accept(mismatchedStartCloseTag, pos);\n  } else if (next != 33 /* '!' */ && next != 63 /* '?' */) {\n    return token.accept(StartTag, pos)\n  }\n});\n\nfunction scanTo(type, end) {\n  return new ExternalTokenizer((input, token) => {\n    let pos = token.start, endPos = 0;\n    for (;;) {\n      let next = input.get(pos);\n      if (next < 0) break\n      pos++;\n      if (next == end.charCodeAt(endPos)) {\n        endPos++;\n        if (endPos == end.length) { pos -= end.length; break }\n      } else {\n        endPos = 0;\n      }\n    }\n    if (pos > token.start) token.accept(type, pos);\n  })\n}\n\nconst commentContent$1 = scanTo(commentContent, \"-->\");\nconst piContent$1 = scanTo(piContent, \"?>\");\nconst cdataContent$1 = scanTo(cdataContent, \"?>\");\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = Parser.deserialize({\n  version: 13,\n  states: \"-OOQOaOOOcObO'#CbOkOdO'#CcOOOP'#Cu'#CuOsOaO'#DSO!XOaOOOOOQ'#Cv'#CvO!aObO,58|OOOP,58|,58|OOOS'#Cw'#CwO!iOdO,58}OOOP,58},58}OOOP-E6s-E6sO!qO`O'#CgO!yOqO'#CeOOOP'#Ce'#CeO#kOaO'#CxQ#|OPOOO$ROaOOOOOQ-E6t-E6tOOOP1G.h1G.hOOOS-E6u-E6uOOOP1G.i1G.iOOOO'#Cy'#CyO$aO`O,59RO$iO!bO,59RO$wOhO'#CpO%PO`O'#CqOOOP'#D['#D[OOOP'#C|'#C|O!yOqO,59PO%XO`O'#CrOOOP,59P,59POOOP,59d,59dOOOP-E6v-E6vO#|OPOOOOOO-E6w-E6wO%aO!bO1G.mO%aO!bO1G.mO%oO`O'#CiO%wO!bO'#CzO&VO!bO1G.mOOOP1G.m1G.mOOOP1G.z1G.zOOOW'#C}'#C}O&bOhO,59[OOOP,59[,59[O&jO`O,59]O&rO`O,59]OOOP-E6z-E6zOOOP1G.k1G.kO&zO`O,59^O'SO`O,59^O'[O!bO7+$XO'jO!bO7+$XOOOP7+$X7+$XOOOP7+$f7+$fO'uO`O,59TO'}O`O,59TO(VO!bO,59fOOOO-E6x-E6xOOOW-E6{-E6{OOOP1G.v1G.vO(eO`O1G.wO(eO`O1G.wOOOP1G.w1G.wO(mO`O1G.xO(mO`O1G.xOOOP1G.x1G.xO(uO!bO<<GsOOOP<<Gs<<GsOOOP<<HQ<<HQO'}O`O1G.oO'}O`O1G.oO)QO#tO'#ClOOOO1G.o1G.oO)`O`O7+$cOOOP7+$c7+$cO)hO`O7+$dOOOP7+$d7+$dOOOPAN=_AN=_OOOPAN=lAN=lO'}O`O7+$ZOOOO7+$Z7+$ZOOOO'#C{'#C{O)pO#tO,59WOOOO,59W,59WOOOP<<G}<<G}OOOP<<HO<<HOOOOO<<Gu<<GuOOOO-E6y-E6yOOOO1G.r1G.r\",\n  stateData: \"*O~OxPOyRO{QOPvPWvP~OsUOwWO~OtXOzZO~OxPOyRO{QOPvXWvXrvX~OP]OWbO~OsUOwdO~OtXOzfO~O[iOygO~OP]OQoORkOSlOalOblOclOxPO{QO!QjO~OxPOyRO{QOPvPrvP~OP]O~OxPOyRO{QOPvP~O[uOygO~OYzO^wOg{OygO~Ou|O!P!OO~O[!QOygO~O[!UOygO~OY!XO^wOg!YOygO~O_![OygO~OygOYnX^nXgnX~OY!XO^wOg!YO~Ou|O!P!`O~O[!aOygO~OY!cOygO~O[!dOygO~OY!fOygO~OY!hO^wOg!iOygO~OY!hO^wOg!iO~O_!jOygO~OygO|!lO~OygOYna^nagna~OY!oOygO~OY!qOygO~OY!rO^wOg!sO~Oa!vOb!vO|!xO}!vO~OY!yOygO~OY!zOygO~Oa!vOb!vO|!}O}!vO~O\",\n  goto: \"&R!PPPPPPP!Q!QP![P!eP!lPP!uPPP!W!W#PP#V#^#f#l#r#y%R%b%h%nPPPP%tPPPPPPP%}WROS`bTl^nU`TasTl^nZ^T^ans_xiuvy!V!W!gQ!m![S!u!j!kR!{!tQp^R!SnZ_T^ansUSO`bR[SQVPRcVQYQReYSaTsRraQh]jthv!P!T!V!Z!]!b!e!k!n!p!tQviQ!PkQ!ToQ!VuQ!ZwQ!]xQ!b!QQ!e!UQ!k![Q!n!aQ!p!dR!t!jQyiS!WuvU!^y!W!gR!g!VQ!w!lR!|!wQn^R!RnQ}jR!_}QTOQq`RsbTm^n\",\n  nodeNames: \"âš  StartTag StartCloseTag StartCloseTag StartCloseTag Document Comment ProcessingInst DoctypeDecl Element EndTag OpenTag TagName Attribute AttributeName Is AttributeValue EntityReference CharacterReference Text Cdata MismatchedCloseTag CloseTag SelfCloseEndTag SelfClosingTag\",\n  maxTerm: 48,\n  context: elementContext,\n  nodeProps: [\n    [NodeProp.closedBy, 1,\"SelfCloseEndTag EndTag\",11,\"CloseTag\"],\n    [NodeProp.openedBy, 10,\"StartTag StartCloseTag\",22,\"OpenTag\",23,\"StartTag\"]\n  ],\n  skippedNodes: [0],\n  repeatNodeCount: 9,\n  tokenData: \"Bk~R!WOX$kXY%rYZ%rZ]$k]^%r^p$kpq%rqr$krs&tsv$kvw'Uw}$k}!O(q!O!P$k!P!Q*n!Q![$k![!]+z!]!^$k!^!_/s!_!`=i!`!a>U!a!b>q!b!c$k!c!}+z!}#P$k#P#Q?}#Q#R$k#R#S+z#S#T$k#T#o+z#o%W$k%W%o+z%o%p$k%p&a+z&a&b$k&b1p+z1p4U$k4U4d+z4d4e$k4e$IS+z$IS$I`$k$I`$Ib+z$Ib$Kh$k$Kh%#t+z%#t&/x$k&/x&Et+z&Et&FV$k&FV;'S+z;'S;:jAz;:j?&r$k?&r?Ah+z?Ah?BY$k?BY?Mn+z?Mn~$kY$rUcQ}WOr$krs%Usv$kw!^$k!^!_%d!_~$kQ%ZRcQOv%Uw!^%U!_~%UW%iR}WOr%dsv%dw~%d_%{]cQ}WyTOX$kXY%rYZ%rZ]$k]^%r^p$kpq%rqr$krs%Usv$kw!^$k!^!_%d!_~$kZ&{R|XcQOv%Uw!^%U!_~%U~'XTOp'hqs'hst(Pt!]'h!^~'h~'kTOp'hqs'ht!]'h!]!^'z!^~'h~(POa~~(SROp(]q!](]!^~(]~(`SOp(]q!](]!]!^(l!^~(]~(qOb~Z(xWcQ}WOr$krs%Usv$kw}$k}!O)b!O!^$k!^!_%d!_~$kZ)iWcQ}WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a*R!a~$kZ*[UwPcQ}WOr$krs%Usv$kw!^$k!^!_%d!_~$k^*uWcQ}WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a+_!a~$k^+hUgScQ}WOr$krs%Usv$kw!^$k!^!_%d!_~$k_,V}^S[PcQ}WOr$krs%Usv$kw}$k}!O+z!O!P+z!P!Q$k!Q![+z![!]+z!]!^$k!^!_%d!_!c$k!c!}+z!}#R$k#R#S+z#S#T$k#T#o+z#o$}$k$}%O+z%O%W$k%W%o+z%o%p$k%p&a+z&a&b$k&b1p+z1p4U+z4U4d+z4d4e$k4e$IS+z$IS$I`$k$I`$Ib+z$Ib$Je$k$Je$Jg+z$Jg$Kh$k$Kh%#t+z%#t&/x$k&/x&Et+z&Et&FV$k&FV;'S+z;'S;:j/S;:j?&r$k?&r?Ah+z?Ah?BY$k?BY?Mn+z?Mn~$k_/ZWcQ}WOr$krs%Usv$kw!^$k!^!_%d!_;=`$k;=`<%l+z<%l~$kZ/xU}WOq%dqr0[sv%dw!a%d!a!b=X!b~%dZ0aZ}WOr%dsv%dw}%d}!O1S!O!f%d!f!g1x!g!}%d!}#O5s#O#W%d#W#X:k#X~%dZ1XT}WOr%dsv%dw}%d}!O1h!O~%dZ1oRxR}WOr%dsv%dw~%dX1}T}WOr%dsv%dw!q%d!q!r2^!r~%dX2cT}WOr%dsv%dw!e%d!e!f2r!f~%dX2wT}WOr%dsv%dw!v%d!v!w3W!w~%dX3]T}WOr%dsv%dw!{%d!{!|3l!|~%dX3qT}WOr%dsv%dw!r%d!r!s4Q!s~%dX4VT}WOr%dsv%dw!g%d!g!h4f!h~%dX4kV}WOr4frs5Qsv4fvw5Qw!`4f!`!a5c!a~4fP5TRO!`5Q!`!a5^!a~5QP5cOWPX5jRWP}WOr%dsv%dw~%dY5xV}WOr%dsv%dw!e%d!e!f6_!f#V%d#V#W8w#W~%dY6dT}WOr%dsv%dw!f%d!f!g6s!g~%dY6xT}WOr%dsv%dw!c%d!c!d7X!d~%dY7^T}WOr%dsv%dw!v%d!v!w7m!w~%dY7rT}WOr%dsv%dw!c%d!c!d8R!d~%dY8WT}WOr%dsv%dw!}%d!}#O8g#O~%dY8nR}W!QQOr%dsv%dw~%dY8|T}WOr%dsv%dw#W%d#W#X9]#X~%dY9bT}WOr%dsv%dw#T%d#T#U9q#U~%dY9vT}WOr%dsv%dw#h%d#h#i:V#i~%dY:[T}WOr%dsv%dw#T%d#T#U8R#U~%dX:pT}WOr%dsv%dw#c%d#c#d;P#d~%dX;UT}WOr%dsv%dw#V%d#V#W;e#W~%dX;jT}WOr%dsv%dw#h%d#h#i;y#i~%dX<OT}WOr%dsv%dw#m%d#m#n<_#n~%dX<dT}WOr%dsv%dw#d%d#d#e<s#e~%dX<xT}WOr%dsv%dw#X%d#X#Y4f#Y~%dZ=`R{R}WOr%dsv%dw~%dZ=rU_PcQ}WOr$krs%Usv$kw!^$k!^!_%d!_~$k_>_UYTcQ}WOr$krs%Usv$kw!^$k!^!_%d!_~$kZ>xWcQ}WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!a?b!a~$kZ?kUzPcQ}WOr$krs%Usv$kw!^$k!^!_%d!_~$kZ@UWcQ}WOr$krs%Usv$kw!^$k!^!_%d!_#P$k#P#Q@n#Q~$kZ@uWcQ}WOr$krs%Usv$kw!^$k!^!_%d!_!`$k!`!aA_!a~$kZAhU!PPcQ}WOr$krs%Usv$kw!^$k!^!_%d!_~$k_BRWcQ}WOr$krs%Usv$kw!^$k!^!_%d!_;=`$k;=`<%l+z<%l~$k\",\n  tokenizers: [startTag, commentContent$1, piContent$1, cdataContent$1, 0, 1, 2, 3],\n  topRules: {\"Document\":[0,5]},\n  tokenPrec: 0\n});\n\nfunction tagName(doc, tag) {\n    let name = tag && tag.getChild(\"TagName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction elementName(doc, tree) {\n    let tag = tree && tree.firstChild;\n    return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\nfunction attrName(doc, tag, pos) {\n    let attr = tag && tag.getChildren(\"Attribute\").find(a => a.from <= pos && a.to >= pos);\n    let name = attr && attr.getChild(\"AttributeName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction findParentElement(tree) {\n    for (let cur = tree && tree.parent; cur; cur = cur.parent)\n        if (cur.name == \"Element\")\n            return cur;\n    return null;\n}\nfunction findLocation(state, pos) {\n    var _a;\n    let at = syntaxTree(state).resolve(pos, -1), inTag = null;\n    for (let cur = at; !inTag && cur.parent; cur = cur.parent)\n        if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\")\n            inTag = cur;\n    if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n        let elt = inTag.parent;\n        if (at.name == \"TagName\")\n            return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\"\n                ? { type: \"closeTag\", from: at.from, context: elt }\n                : { type: \"openTag\", from: at.from, context: findParentElement(elt) };\n        if (at.name == \"AttributeName\")\n            return { type: \"attrName\", from: at.from, context: inTag };\n        if (at.name == \"AttributeValue\")\n            return { type: \"attrValue\", from: at.from, context: inTag };\n        let before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\")\n            return { type: \"openTag\", from: pos, context: findParentElement(elt) };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos)\n            return { type: \"closeTag\", from: pos, context: elt };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\")\n            return { type: \"attrValue\", from: pos, context: inTag };\n        if (before)\n            return { type: \"attrName\", from: pos, context: inTag };\n        return null;\n    }\n    else if (at.name == \"StartCloseTag\") {\n        return { type: \"closeTag\", from: pos, context: at.parent };\n    }\n    while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError))\n        at = at.parent;\n    if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\")\n        return { type: \"tag\", from: pos, context: at.name == \"Element\" ? at : findParentElement(at) };\n    return null;\n}\nclass Element {\n    constructor(spec, attrs, attrValues) {\n        this.attrs = attrs;\n        this.attrValues = attrValues;\n        this.children = [];\n        this.name = spec.name;\n        this.completion = Object.assign(Object.assign({ type: \"type\" }, spec.completion || {}), { label: this.name });\n        this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: \"<\" + this.name });\n        this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: \"</\" + this.name + \">\", boost: 2 });\n        this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + \">\" });\n        this.text = spec.textContent ? spec.textContent.map(s => ({ label: s, type: \"text\" })) : [];\n    }\n}\nconst Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction attrCompletion(spec) {\n    return Object.assign(Object.assign({ type: \"property\" }, spec.completion || {}), { label: spec.name });\n}\nfunction valueCompletion(spec) {\n    return typeof spec == \"string\" ? { label: `\"${spec}\"`, type: \"constant\" }\n        : /^\"/.test(spec.label) ? spec\n            : Object.assign(Object.assign({}, spec), { label: `\"${spec.label}\"` });\n}\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n    let allAttrs = [], globalAttrs = [];\n    let attrValues = Object.create(null);\n    for (let s of attrSpecs) {\n        let completion = attrCompletion(s);\n        allAttrs.push(completion);\n        if (s.global)\n            globalAttrs.push(completion);\n        if (s.values)\n            attrValues[s.name] = s.values.map(valueCompletion);\n    }\n    let allElements = [], topElements = [];\n    let byName = Object.create(null);\n    for (let s of eltSpecs) {\n        let attrs = globalAttrs, attrVals = attrValues;\n        if (s.attributes)\n            attrs = attrs.concat(s.attributes.map(s => {\n                if (typeof s == \"string\")\n                    return allAttrs.find(a => a.label == s) || { label: s, type: \"property\" };\n                if (s.values) {\n                    if (attrVals == attrValues)\n                        attrVals = Object.create(attrVals);\n                    attrVals[s.name] = s.values.map(valueCompletion);\n                }\n                return attrCompletion(s);\n            }));\n        let elt = new Element(s, attrs, attrVals);\n        byName[elt.name] = elt;\n        allElements.push(elt);\n        if (s.top)\n            topElements.push(elt);\n    }\n    if (!topElements.length)\n        topElements = allElements;\n    for (let i = 0; i < allElements.length; i++) {\n        let s = eltSpecs[i], elt = allElements[i];\n        if (s.children) {\n            for (let ch of s.children)\n                if (byName[ch])\n                    elt.children.push(byName[ch]);\n        }\n        else {\n            elt.children = allElements;\n        }\n    }\n    return cx => {\n        var _a;\n        let { doc } = cx.state, loc = findLocation(cx.state, cx.pos);\n        if (!loc || (loc.type == \"tag\" && !cx.explicit))\n            return null;\n        let { type, from, context } = loc;\n        if (type == \"openTag\") {\n            let children = topElements;\n            let parentName = elementName(doc, context);\n            if (parentName) {\n                let parent = byName[parentName];\n                children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n            }\n            return {\n                from,\n                options: children.map(ch => ch.completion),\n                span: Identifier\n            };\n        }\n        else if (type == \"closeTag\") {\n            let parentName = elementName(doc, context);\n            return parentName ? {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n                options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || { label: parentName + \">\", type: \"type\" }],\n                span: Identifier\n            } : null;\n        }\n        else if (type == \"attrName\") {\n            let parent = byName[tagName(doc, context)];\n            return {\n                from,\n                options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,\n                span: Identifier\n            };\n        }\n        else if (type == \"attrValue\") {\n            let attr = attrName(doc, context, from);\n            if (!attr)\n                return null;\n            let parent = byName[tagName(doc, context)];\n            let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];\n            if (!values || !values.length)\n                return null;\n            return {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n                options: values,\n                span: /^\"[^\"]*\"?$/\n            };\n        }\n        else if (type == \"tag\") {\n            let parentName = elementName(doc, context), parent = byName[parentName];\n            let closing = [], last = context && context.lastChild;\n            if (parentName && (!last || last.name != \"CloseTag\" || tagName(doc, last) != parentName))\n                closing.push(parent ? parent.closeCompletion : { label: \"</\" + parentName + \">\", type: \"type\", boost: 2 });\n            let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));\n            if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {\n                let openTag = context.firstChild;\n                if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos)))\n                    options = options.concat(parent.text);\n            }\n            return {\n                from,\n                options,\n                span: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n            };\n        }\n        else {\n            return null;\n        }\n    };\n}\n\n/// A language provider based on the [Lezer XML\n/// parser](https://github.com/lezer-parser/xml), extended with\n/// highlighting and indentation information.\nconst xmlLanguage = LezerLanguage.define({\n    parser: parser.configure({\n        props: [\n            indentNodeProp.add({\n                Element(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.state.doc.lineAt(context.node.from)) + (closed ? 0 : context.unit);\n                },\n                \"OpenTag CloseTag SelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            foldNodeProp.add({\n                Element(subtree) {\n                    let first = subtree.firstChild, last = subtree.lastChild;\n                    if (!first || first.name != \"OpenTag\")\n                        return null;\n                    return { from: first.to, to: last.name == \"CloseTag\" ? last.from : subtree.to };\n                }\n            }),\n            styleTags({\n                AttributeValue: tags.string,\n                Text: tags.content,\n                \"StartTag StartCloseTag EndTag SelfCloseEndTag\": tags.angleBracket,\n                TagName: tags.tagName,\n                \"MismatchedCloseTag/Tagname\": [tags.tagName, tags.invalid],\n                AttributeName: tags.propertyName,\n                UnquotedAttributeValue: tags.string,\n                Is: tags.definitionOperator,\n                \"EntityReference CharacterReference\": tags.character,\n                Comment: tags.blockComment,\n                ProcessingInst: tags.processingInstruction,\n                DoctypeDecl: tags.documentMeta,\n                Cdata: tags.special(tags.string)\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"<!--\", close: \"-->\" } },\n        indentOnInput: /^\\s*<\\/$/\n    }\n});\n/// XML language support. Includes schema-based autocompletion when\n/// configured.\nfunction xml(conf = {}) {\n    return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n        autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n    }));\n}\n\nexport { completeFromSchema, xml, xmlLanguage };\n"],"sourceRoot":""}